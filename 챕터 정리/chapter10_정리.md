# chapter 10 정리

## 연산자 오버로딩

- 연산자를 실행하는 것은 함수를 실행하는 것과 같다!
  - operator+
- 연산자는 객체다!

- 연산자 오버로딩은
  - c++이 피연산자가 기본 자료형 변수라면 연산을 하고
  - 피연산자가 객체라면 operator연산자()를 실행하도록 약속한 것.
  - pos1 + pos2 == pos1.operator+(pos2)

- 연산자 오버로딩을 하는 방법
  1. 멤버함수에 의한 연산자 오버로딩 pos1.operator+(pos2)
  2. 전역함수에 의한 연산자 오버로딩 operator+(pos1, pos2)
  3. 멤버함수 기반이 우선 실행

- 연산자 오버로딩 주의사항
  - 본래의의도를벗어난형태의연산자오버로딩은좋지않다!
    - 프로그램을혼란스럽게만들수있다.
  - 연산자의우선순위와결합성은바뀌지않는다. (?)
    - 따라서이둘을고려해서연산자를오버로딩해야한다.
  - 매개변수의디폴트값설정이불가능하다.
    - 매개변수의자료형에따라서호출되는함수가결정되므로.
  - 연산자의순수기능까지빼앗을수는없다.

## 단항 연산자의 오버로딩

- 단항연산자: ++, --
- pos1.operator+()
- operator+(pos1)
- 기본적으로 전위연산이다 (++pos)
- 후위 연산은 int를 넣어서 구현 pos1.operator+(int)

### 반환형에서 const 선언과 const 객체

```C++
const Point operator++(int)
{
  const Point retobj(xpos, ypos);   // const Point retobj(*this);
                                    // const 객체
                                    // 함수 내에서 retobj 변경을 막는다.
  xpos+=1;
  ypos+=1;
  return retobj; // 반환형이 const로 선언되었다.
                 // 함수의 반환으로 생기는 임시객체를 const 객체로 생성
}
```

- 함수의 반환되는 객체를 const 객체화 했다.
  - const 객체는 const로 선언되지 않은 멤버함수 호출 불가능
  - const 객체는 const로 선언되지 않은 함수의 호출이 불가능
  - 반환되는 객체를 대상으로 const로 선언되지 않은 함수의 호출이 불가능
  - 왜 이렇게 했을까?

- (pos++)++를 막기 위함이다. (C++ 특징)
  - (pos++)++;
  - (Point형 const 임시객체)++;
  - (Point형 const 임시객체).operator++();
    - 여기서 operator++()는 const 함수가 아니기 때문에 컴파일 에러

## 교환법칙 문제의 해결

- 자료형이 다른 두 피연산자를 대상으로 하는 연산
- 전역함수 형태로 오버로딩
  - 방법 1: 교환법칙에 맞게 함수르 새로 구현
  - 방법 2: 멤버함수로 구현한 연산자 오버로딩을 호출

## cout, cin 그리고 endl의 정체

- << 이것도 역시 객체다.
- *this 반환으로 연이은 함수 호출
