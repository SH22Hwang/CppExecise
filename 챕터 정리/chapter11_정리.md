# chapter 11 정리

## 대입 연산자 오버로딩

- 복사생성자와 비슷하다.
- 디폴트 대입연산자의 문제점은 디폴트 복사생성자(얕은 복사)의 문제점과 같다!
  - 소멸자 1번만 실행됨.
  - +메모리 누수
  - 해결하는 방법은 아래와 같다.
    - 메모리 해제 연산 처음에 선언
    - 깊은 복사맨치로 실행

- 상속 구조에서의 대입연산자 호출
  - 디폴트 대입연산자는 기초클래스의 대입연산자를 호출해주지만
  - 명시적으로 정의하면 기초클래스의 대입연산자를 별도로 호출해야한다.

- 이니셜라이저를 쓰면 좋은 점
  - 함수 호출 줄어듦
  - 생성자와 대입연산자 각각 실행되는 것을 바꿈

## 배열의 인덱스 연산자 오버라이딩

- 배열 클래스를 쓰는 이유
  - 기본 배열은 경계검사를 하지 않음
  - 배열 클래스는 이를 구현했다
  - 배열 클래스는 복사생성자 및 대입 연산자를 선언하지 않는게 좋다
    - 아니면 private
    - 배열 안에 있는 데이터 보호
- const 함수를 이용한 오버로딩
  - const 함수를 안 쓰면 const 함수를 못 씀(Show__)
  - const 함수를 쓰면 배열에 저장 불가능
  - const 유무로 함수 오버로딩 보통 동시에 정의함
- 객체의 저장을 위한 배열 클래스
  - 객체를 통채로 저장
  - 객체의 주소만 저장
    - 주소만 저장하는게 더 일반적임
    - 통채로 저장하면 대입함. 얕은 복사 깊은 복사 신경써야함

## 그 이외 연산자 오버로딩

### new, delete 연산자 오버로딩

- new 연산자는 메모리 공간의 할당작업만 오버로딩
- 자동으로 static 선언
  - 객체가 생성된 상태가 아닌데도 불구하고 new 연산자를 오버로딩하고 있는 멤버 함수 호출
- delete 오버로딩은 메모리 관리 해야함

### new, new[]

- new, new[]